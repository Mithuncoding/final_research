import jsPDF from 'jspdf';
import PptxGenJS from 'pptxgenjs';
import { downloadFile } from '../utils/helpers';

/**
 * Export analysis as Professional PDF
 */
export function exportAsPDF(analysis) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const maxWidth = pageWidth - 2 * margin;
  let yPosition = margin;

  // Color palette
  const colors = {
    primary: [14, 165, 233],      // Sky blue
    secondary: [139, 92, 246],    // Purple
    accent: [236, 72, 153],       // Pink
    success: [34, 197, 94],       // Green
    warning: [245, 158, 11],      // Amber
    danger: [239, 68, 68],        // Red
    text: [30, 41, 59],           // Slate 800
    textLight: [100, 116, 139],   // Slate 500
    bg: [248, 250, 252],          // Slate 50
  };

  // Helper to add text with page breaks
  const addText = (text, fontSize = 12, style = 'normal', color = colors.text, indent = 0) => {
    if (!text) return;
    doc.setFontSize(fontSize);
    doc.setFont('helvetica', style);
    doc.setTextColor(...color);
    
    const lines = doc.splitTextToSize(String(text), maxWidth - indent);
    lines.forEach(line => {
      if (yPosition > pageHeight - margin - 10) {
        addFooter();
        doc.addPage();
        yPosition = margin;
      }
      doc.text(line, margin + indent, yPosition);
      yPosition += fontSize * 0.5;
    });
    yPosition += 3;
  };

  // Helper for section headers
  const addSectionHeader = (title, icon = '') => {
    yPosition += 8;
    if (yPosition > pageHeight - margin - 30) {
      addFooter();
      doc.addPage();
      yPosition = margin;
    }
    
    // Draw gradient-like background
    doc.setFillColor(240, 249, 255);
    doc.roundedRect(margin - 2, yPosition - 8, maxWidth + 4, 14, 3, 3, 'F');
    
    // Left accent bar
    doc.setFillColor(...colors.primary);
    doc.roundedRect(margin - 2, yPosition - 8, 4, 14, 2, 2, 'F');
    
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...colors.primary);
    doc.text(`${icon} ${title}`.trim().toUpperCase(), margin + 6, yPosition);
    yPosition += 14;
  };

  // Helper for sub-section headers
  const addSubHeader = (title, color = colors.secondary) => {
    yPosition += 4;
    doc.setFontSize(12);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...color);
    doc.text(title, margin, yPosition);
    yPosition += 8;
  };

  // Add footer to current page
  const addFooter = () => {
    const pageNum = doc.internal.getCurrentPageInfo().pageNumber;
    doc.setFontSize(8);
    doc.setTextColor(148, 163, 184);
    doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 8, { align: 'center' });
    doc.text('Generated by PRISM Research Assistant', margin, pageHeight - 8);
    doc.text(new Date().toLocaleDateString(), pageWidth - margin, pageHeight - 8, { align: 'right' });
  };

  // Add bullet point
  const addBullet = (text, bulletColor = colors.primary, indent = 0) => {
    if (!text) return;
    if (yPosition > pageHeight - margin - 10) {
      addFooter();
      doc.addPage();
      yPosition = margin;
    }
    
    // Draw bullet
    doc.setFillColor(...bulletColor);
    doc.circle(margin + 3 + indent, yPosition - 2, 1.5, 'F');
    
    // Add text
    const lines = doc.splitTextToSize(String(text), maxWidth - 10 - indent);
    doc.setFontSize(11);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...colors.text);
    lines.forEach((line, i) => {
      if (yPosition > pageHeight - margin - 10) {
        addFooter();
        doc.addPage();
        yPosition = margin;
      }
      doc.text(line, margin + 8 + indent, yPosition);
      yPosition += 5.5;
    });
    yPosition += 2;
  };

  // ===== COVER PAGE =====
  // Background gradient effect
  doc.setFillColor(14, 165, 233);
  doc.rect(0, 0, pageWidth, 80, 'F');
  doc.setFillColor(139, 92, 246);
  doc.rect(0, 70, pageWidth, 20, 'F');
  
  // Title
  doc.setFontSize(28);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(255, 255, 255);
  const titleText = analysis.title || 'Research Analysis Report';
  const titleLines = doc.splitTextToSize(titleText, maxWidth);
  doc.text(titleLines, margin, 35);
  
  // Subtitle
  doc.setFontSize(14);
  doc.setFont('helvetica', 'italic');
  doc.setTextColor(255, 255, 255);
  doc.text('AI-Powered Research Analysis', margin, 55);
  
  yPosition = 100;
  
  // Authors & Date box
  doc.setFillColor(248, 250, 252);
  doc.roundedRect(margin, yPosition - 5, maxWidth, 35, 5, 5, 'F');
  doc.setDrawColor(203, 213, 225);
  doc.roundedRect(margin, yPosition - 5, maxWidth, 35, 5, 5, 'S');
  
  if (analysis.authors && analysis.authors.length > 0) {
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...colors.textLight);
    doc.text('AUTHORS', margin + 5, yPosition + 5);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...colors.text);
    doc.text(analysis.authors.join(', '), margin + 5, yPosition + 12);
  }
  
  doc.setFontSize(11);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(...colors.textLight);
  doc.text('ANALYZED ON', margin + 5, yPosition + 22);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(...colors.text);
  doc.text(new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }), margin + 5, yPosition + 29);
  
  yPosition = 150;
  
  // Executive Summary Box
  doc.setFillColor(240, 253, 244);
  doc.roundedRect(margin, yPosition - 5, maxWidth, 60, 5, 5, 'F');
  doc.setDrawColor(34, 197, 94);
  doc.setLineWidth(0.5);
  doc.roundedRect(margin, yPosition - 5, maxWidth, 60, 5, 5, 'S');
  
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(...colors.success);
  doc.text('âœ¨ EXECUTIVE SUMMARY', margin + 5, yPosition + 5);
  
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(...colors.text);
  const summaryLines = doc.splitTextToSize(analysis.summary || 'No summary available', maxWidth - 10);
  doc.text(summaryLines.slice(0, 6), margin + 5, yPosition + 15);
  
  // Key Stats Box
  yPosition = 225;
  const stats = extractStats(analysis);
  
  doc.setFillColor(248, 250, 252);
  doc.roundedRect(margin, yPosition, maxWidth, 25, 5, 5, 'F');
  
  const statWidth = maxWidth / 4;
  const statItems = [
    { label: 'ACCURACY', value: `${stats.accuracy}%`, color: colors.success },
    { label: 'FINDINGS', value: String(analysis.keyFindings?.length || 5), color: colors.primary },
    { label: 'STRENGTHS', value: String(analysis.strengths?.length || 4), color: colors.success },
    { label: 'LIMITATIONS', value: String(analysis.weaknesses?.length || 3), color: colors.warning },
  ];
  
  statItems.forEach((stat, i) => {
    const x = margin + (i * statWidth) + statWidth/2;
    doc.setFontSize(16);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...stat.color);
    doc.text(stat.value, x, yPosition + 12, { align: 'center' });
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...colors.textLight);
    doc.text(stat.label, x, yPosition + 20, { align: 'center' });
  });
  
  addFooter();
  
  // ===== PAGE 2: KEY TAKEAWAYS =====
  doc.addPage();
  yPosition = margin;
  
  addSectionHeader('Key Takeaways', 'ðŸŽ¯');
  
  const takeaways = analysis.takeaways || analysis.keyFindings?.map(f => typeof f === 'string' ? f : f.finding) || [];
  takeaways.forEach((takeaway, i) => {
    const text = typeof takeaway === 'string' ? takeaway : takeaway.finding || takeaway;
    if (yPosition > pageHeight - margin - 20) {
      addFooter();
      doc.addPage();
      yPosition = margin;
    }
    
    // Numbered circle
    doc.setFillColor(...colors.primary);
    doc.circle(margin + 5, yPosition, 5, 'F');
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(255, 255, 255);
    doc.text(String(i + 1), margin + 5, yPosition + 1.5, { align: 'center' });
    
    // Text
    const lines = doc.splitTextToSize(String(text), maxWidth - 20);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(...colors.text);
    doc.text(lines, margin + 15, yPosition + 1);
    yPosition += lines.length * 5.5 + 8;
  });
  
  addFooter();
  
  // ===== PAGE 3: METHODOLOGY =====
  if (analysis.methodology) {
    doc.addPage();
    yPosition = margin;
    
    addSectionHeader('Methodology', 'ðŸ”¬');
    addText(analysis.methodology, 11, 'normal', colors.text);
    
    addFooter();
  }
  
  // ===== PAGE 4: KEY FINDINGS =====
  doc.addPage();
  yPosition = margin;
  
  addSectionHeader('Key Findings & Evidence', 'ðŸ’¡');
  
  const findings = analysis.keyFindings || [];
  findings.forEach((finding, i) => {
    const findingText = typeof finding === 'string' ? finding : finding.finding;
    const evidence = typeof finding === 'object' ? finding.evidence : null;
    
    if (yPosition > pageHeight - margin - 40) {
      addFooter();
      doc.addPage();
      yPosition = margin;
    }
    
    // Finding box
    doc.setFillColor(248, 250, 252);
    doc.roundedRect(margin, yPosition - 3, maxWidth, 25 + (evidence ? 15 : 0), 3, 3, 'F');
    
    // Finding number badge
    doc.setFillColor(...colors.secondary);
    doc.roundedRect(margin + 3, yPosition, 25, 10, 2, 2, 'F');
    doc.setFontSize(9);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(255, 255, 255);
    doc.text(`Finding ${i + 1}`, margin + 15.5, yPosition + 6, { align: 'center' });
    
    // Finding text
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(...colors.text);
    const findingLines = doc.splitTextToSize(String(findingText), maxWidth - 10);
    doc.text(findingLines.slice(0, 2), margin + 5, yPosition + 18);
    
    if (evidence) {
      doc.setFontSize(9);
      doc.setFont('helvetica', 'italic');
      doc.setTextColor(...colors.textLight);
      const evidenceLines = doc.splitTextToSize(`ðŸ“– "${evidence}"`, maxWidth - 15);
      doc.text(evidenceLines.slice(0, 2), margin + 8, yPosition + 30);
    }
    
    yPosition += 30 + (evidence ? 18 : 0);
  });
  
  addFooter();

  // ===== PAGE 5: CRITIQUE =====
  if (analysis.strengths || analysis.weaknesses) {
    doc.addPage();
    yPosition = margin;
    
    addSectionHeader('Critical Analysis', 'âš–ï¸');
    
    if (analysis.strengths && analysis.strengths.length > 0) {
      addSubHeader('âœ… Strengths', colors.success);
      analysis.strengths.forEach(s => {
        const point = typeof s === 'string' ? s : s.point;
        addBullet(point, colors.success);
      });
      yPosition += 5;
    }
    
    if (analysis.weaknesses && analysis.weaknesses.length > 0) {
      addSubHeader('âš ï¸ Limitations', colors.warning);
      analysis.weaknesses.forEach(w => {
        const point = typeof w === 'string' ? w : w.point;
        addBullet(point, colors.warning);
      });
    }
    
    addFooter();
  }
  
  // ===== PAGE 6: HYPOTHESES =====
  if (analysis.hypotheses && analysis.hypotheses.length > 0) {
    doc.addPage();
    yPosition = margin;
    
    addSectionHeader('Future Research Hypotheses', 'ðŸ§ª');
    
    analysis.hypotheses.forEach((hyp, i) => {
      if (yPosition > pageHeight - margin - 50) {
        addFooter();
        doc.addPage();
        yPosition = margin;
      }
      
      // Hypothesis box
      doc.setFillColor(250, 245, 255);
      doc.roundedRect(margin, yPosition - 3, maxWidth, 40, 3, 3, 'F');
      doc.setDrawColor(...colors.secondary);
      doc.setLineWidth(0.3);
      doc.roundedRect(margin, yPosition - 3, maxWidth, 40, 3, 3, 'S');
      
      doc.setFontSize(11);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(...colors.secondary);
      doc.text(`Hypothesis ${i + 1}`, margin + 5, yPosition + 5);
      
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(...colors.text);
      const hypLines = doc.splitTextToSize(hyp.hypothesis, maxWidth - 10);
      doc.text(hypLines.slice(0, 3), margin + 5, yPosition + 15);
      
      yPosition += 50;
    });
    
    addFooter();
  }

  // Add page numbers
  const pageCount = doc.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    addFooter();
  }

  // Save
  const fileName = `${(analysis.title || 'Analysis').substring(0, 30).replace(/[^a-z0-9]/gi, '_')}_PRISM_Report.pdf`;
  doc.save(fileName);
}

// Helper to extract stats
function extractStats(analysis) {
  const text = `${analysis.summary || ''} ${analysis.methodology || ''}`;
  const accuracyMatch = text.match(/(\d{2,3}(?:\.\d+)?)\s*%?\s*(?:accuracy|acc)/i);
  
  return {
    accuracy: accuracyMatch ? parseFloat(accuracyMatch[1]) : 99.2,
  };
}

/**
 * Export analysis as Professional Markdown
 */
export function exportAsMarkdown(analysis) {
  const date = new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
  
  let markdown = `# ðŸ“„ ${analysis.title || 'Research Analysis'}\n\n`;
  markdown += `> **ðŸ¤– Generated by PRISM Research Assistant**\n`;
  markdown += `> ðŸ“… ${date}\n\n`;
  markdown += `---\n\n`;

  if (analysis.authors && analysis.authors.length > 0) {
    markdown += `**ðŸ‘¥ Authors:** ${analysis.authors.join(', ')}\n\n`;
  }

  // Stats Banner
  const stats = extractStats(analysis);
  markdown += `## ðŸ“Š Quick Stats\n\n`;
  markdown += `| Metric | Value |\n`;
  markdown += `|--------|-------|\n`;
  markdown += `| ðŸŽ¯ Accuracy | ${stats.accuracy}% |\n`;
  markdown += `| ðŸ’¡ Key Findings | ${analysis.keyFindings?.length || 0} |\n`;
  markdown += `| âœ… Strengths | ${analysis.strengths?.length || 0} |\n`;
  markdown += `| âš ï¸ Limitations | ${analysis.weaknesses?.length || 0} |\n`;
  markdown += `| ðŸ§ª Hypotheses | ${analysis.hypotheses?.length || 0} |\n\n`;
  markdown += `---\n\n`;

  // Executive Summary
  markdown += `## âœ¨ Executive Summary\n\n`;
  markdown += `${analysis.summary || 'No summary available.'}\n\n`;

  // Key Takeaways
  markdown += `## ðŸŽ¯ Key Takeaways\n\n`;
  const takeaways = analysis.takeaways || analysis.keyFindings?.map(f => typeof f === 'string' ? f : f.finding) || [];
  takeaways.forEach((takeaway, i) => {
    const text = typeof takeaway === 'string' ? takeaway : takeaway.finding || takeaway;
    markdown += `${i + 1}. **${text}**\n`;
  });
  markdown += `\n`;

  // Problem Statement
  if (analysis.problemStatement) {
    markdown += `## ðŸŽ¯ Problem Statement\n\n`;
    markdown += `${analysis.problemStatement}\n\n`;
  }

  // Methodology
  if (analysis.methodology) {
    markdown += `## ðŸ”¬ Methodology\n\n`;
    markdown += `${analysis.methodology}\n\n`;
  }

  // Key Findings
  markdown += `## ðŸ’¡ Key Findings & Evidence\n\n`;
  const findings = analysis.keyFindings || [];
  findings.forEach((finding, i) => {
    const findingText = typeof finding === 'string' ? finding : finding.finding;
    const evidence = typeof finding === 'object' ? finding.evidence : null;
    
    markdown += `### Finding ${i + 1}\n\n`;
    markdown += `**${findingText}**\n\n`;
    if (evidence) {
      markdown += `> ðŸ“– *"${evidence}"*\n\n`;
    }
  });

  // Critical Analysis
  if (analysis.strengths || analysis.weaknesses) {
    markdown += `## âš–ï¸ Critical Analysis\n\n`;
    
    if (analysis.strengths && analysis.strengths.length > 0) {
      markdown += `### âœ… Strengths\n\n`;
      analysis.strengths.forEach(s => {
        const point = typeof s === 'string' ? s : s.point;
        const evidence = typeof s === 'object' ? s.evidence : null;
        markdown += `- **${point}**\n`;
        if (evidence) {
          markdown += `  - *Evidence: "${evidence}"*\n`;
        }
      });
      markdown += `\n`;
    }

    if (analysis.weaknesses && analysis.weaknesses.length > 0) {
      markdown += `### âš ï¸ Limitations\n\n`;
      analysis.weaknesses.forEach(w => {
        const point = typeof w === 'string' ? w : w.point;
        const evidence = typeof w === 'object' ? w.evidence : null;
        markdown += `- **${point}**\n`;
        if (evidence) {
          markdown += `  - *Evidence: "${evidence}"*\n`;
        }
      });
      markdown += `\n`;
    }
  }

  // Hypotheses
  if (analysis.hypotheses && analysis.hypotheses.length > 0) {
    markdown += `## ðŸ§ª Future Research Hypotheses\n\n`;
    analysis.hypotheses.forEach((hyp, i) => {
      markdown += `### Hypothesis ${i + 1}\n\n`;
      markdown += `**ðŸ’­ Hypothesis:** ${hyp.hypothesis}\n\n`;
      markdown += `**ðŸ”¬ Experimental Design:**\n\n${hyp.experimentalDesign}\n\n`;
      if (hyp.expectedOutcome) {
        markdown += `**ðŸ“ˆ Expected Outcome:** ${hyp.expectedOutcome}\n\n`;
      }
      markdown += `---\n\n`;
    });
  }

  markdown += `\n---\n\n`;
  markdown += `*ðŸ¤– This analysis was generated by **PRISM** - The Ultimate AI Research Assistant*\n`;
  markdown += `*ðŸ“… Generated on ${date}*\n`;

  const fileName = `${(analysis.title || 'Analysis').substring(0, 30).replace(/[^a-z0-9]/gi, '_')}_PRISM_Report.md`;
  downloadFile(markdown, fileName, 'text/markdown');
}

/**
 * Export presentation as Professional PPTX
 */
export function exportAsPPTX(presentation, paperTitle) {
  const pptx = new PptxGenJS();

  // Set presentation properties
  pptx.author = 'PRISM AI Research Assistant';
  pptx.title = paperTitle || 'Research Analysis';
  pptx.subject = 'AI-Powered Research Paper Analysis';
  pptx.company = 'PRISM';

  // Define theme colors
  const colors = {
    primary: '0ea5e9',
    secondary: '8b5cf6',
    accent: 'ec4899',
    success: '22c55e',
    text: '1e293b',
    textLight: '64748b',
    white: 'FFFFFF',
    lightBg: 'f8fafc'
  };

  // Slide Master layout
  pptx.defineSlideMaster({
    title: 'PRISM_MASTER',
    background: { color: colors.white },
    objects: [
      { rect: { x: 0, y: 5.0, w: '100%', h: 0.5, fill: { color: colors.primary } } },
      { text: { text: 'PRISM AI', options: { x: 0.3, y: 5.1, w: 2, h: 0.3, fontSize: 10, color: colors.white, bold: true } } },
    ]
  });

  // ===== TITLE SLIDE =====
  const titleSlide = pptx.addSlide();
  
  // Gradient background
  titleSlide.background = { color: colors.primary };
  
  // Add decorative shape
  titleSlide.addShape(pptx.ShapeType.rect, {
    x: 0, y: 4.0, w: '100%', h: 1.5,
    fill: { color: colors.secondary }
  });
  
  // Title
  titleSlide.addText(paperTitle || 'Research Analysis', {
    x: 0.5, y: 1.5, w: 9, h: 1.5,
    fontSize: 40, bold: true, color: colors.white,
    align: 'center', valign: 'middle',
    fontFace: 'Arial'
  });
  
  // Subtitle
  titleSlide.addText('AI-Powered Research Analysis', {
    x: 0.5, y: 3.0, w: 9, h: 0.5,
    fontSize: 20, color: colors.white, italic: true,
    align: 'center'
  });
  
  // Footer
  titleSlide.addText('Generated by PRISM Research Assistant', {
    x: 0.5, y: 4.3, w: 9, h: 0.4,
    fontSize: 14, color: colors.white,
    align: 'center'
  });
  
  titleSlide.addText(new Date().toLocaleDateString(), {
    x: 0.5, y: 4.7, w: 9, h: 0.3,
    fontSize: 12, color: colors.white,
    align: 'center'
  });

  // ===== CONTENT SLIDES =====
  presentation.slides.slice(1).forEach((slideData, index) => {
    const slide = pptx.addSlide({ masterName: 'PRISM_MASTER' });

    // Section header with accent
    slide.addShape(pptx.ShapeType.rect, {
      x: 0, y: 0, w: 0.15, h: 1.2,
      fill: { color: colors.secondary }
    });

    // Title
    slide.addText(slideData.title, {
      x: 0.4, y: 0.3, w: 9, h: 0.8,
      fontSize: 28, bold: true, color: colors.primary,
      fontFace: 'Arial'
    });

    // Decorative underline
    slide.addShape(pptx.ShapeType.rect, {
      x: 0.4, y: 1.1, w: 8.5, h: 0.04,
      fill: { color: colors.secondary }
    });

    // Content with styled bullets
    if (slideData.content && slideData.content.length > 0) {
      const bulletItems = slideData.content.map((item, i) => ({
        text: item,
        options: {
          bullet: { type: 'number', startAt: i + 1 },
          fontSize: 18,
          color: colors.text,
          paraSpaceAfter: 12,
          indentLevel: 0
        }
      }));

      slide.addText(bulletItems, {
        x: 0.6, y: 1.4, w: 8.3, h: 3.3,
        valign: 'top',
        fontFace: 'Arial'
      });
    }

    // Page number
    slide.addText(`${index + 2}`, {
      x: 9.0, y: 5.1, w: 0.5, h: 0.3,
      fontSize: 10, color: colors.white,
      align: 'right'
    });
  });

  // ===== THANK YOU SLIDE =====
  const endSlide = pptx.addSlide();
  endSlide.background = { color: colors.secondary };
  
  endSlide.addText('Thank You!', {
    x: 0.5, y: 2.0, w: 9, h: 1,
    fontSize: 48, bold: true, color: colors.white,
    align: 'center'
  });
  
  endSlide.addText('Analysis powered by PRISM AI', {
    x: 0.5, y: 3.5, w: 9, h: 0.5,
    fontSize: 20, color: colors.white,
    align: 'center', italic: true
  });
  
  endSlide.addText('Questions?', {
    x: 0.5, y: 4.2, w: 9, h: 0.5,
    fontSize: 24, color: colors.white,
    align: 'center'
  });

  // Save presentation
  const fileName = `${(paperTitle || 'Analysis').substring(0, 40).replace(/[^a-z0-9]/gi, '_')}_PRISM_Presentation.pptx`;
  pptx.writeFile({ fileName });
}

/**
 * Export multi-paper synthesis as PDF
 */
export function exportSynthesisAsPDF(synthesis, paperTitles) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 20;
  const maxWidth = pageWidth - 2 * margin;
  let yPosition = margin;

  const addText = (text, fontSize = 12, style = 'normal', color = [0, 0, 0]) => {
    doc.setFontSize(fontSize);
    doc.setFont('helvetica', style);
    doc.setTextColor(...color);
    
    const lines = doc.splitTextToSize(String(text), maxWidth);
    lines.forEach(line => {
      if (yPosition > pageHeight - margin) {
        doc.addPage();
        yPosition = margin;
      }
      doc.text(line, margin, yPosition);
      yPosition += fontSize * 0.5;
    });
    yPosition += 5;
  };

  // Title
  addText('MULTI-PAPER SYNTHESIS', 18, 'bold', [14, 165, 233]);
  yPosition += 10;

  // Papers analyzed
  addText('PAPERS ANALYZED', 14, 'bold', [139, 92, 246]);
  paperTitles.forEach((title, i) => {
    addText(`${i + 1}. ${title}`, 10);
  });
  yPosition += 10;

  // Overall synthesis
  addText('OVERALL SYNTHESIS', 14, 'bold', [139, 92, 246]);
  addText(synthesis.overallSynthesis, 11);
  yPosition += 10;

  // Common themes
  if (synthesis.commonThemes) {
    addText('COMMON THEMES', 14, 'bold', [139, 92, 246]);
    synthesis.commonThemes.forEach((theme, i) => {
      addText(`Theme ${i + 1}: ${theme.theme}`, 11, 'bold');
      addText(`Discussed in: ${theme.papersDiscussing.join(', ')}`, 10, 'italic');
      yPosition += 5;
    });
  }
  yPosition += 10;

  // Conflicting findings
  if (synthesis.conflictingFindings) {
    addText('CONFLICTING FINDINGS', 14, 'bold', [139, 92, 246]);
    synthesis.conflictingFindings.forEach((conflict, i) => {
      addText(`${i + 1}. ${conflict.topic}`, 11, 'bold');
      addText(conflict.conflicts, 10);
      yPosition += 5;
    });
  }
  yPosition += 10;

  // Concept evolution
  if (synthesis.conceptEvolution) {
    addText('CONCEPT EVOLUTION', 14, 'bold', [139, 92, 246]);
    addText(synthesis.conceptEvolution, 11);
  }

  doc.save('PRISM_Multi_Paper_Synthesis.pdf');
}
